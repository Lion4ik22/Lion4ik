Прямых констант (const) в javascript не бывает
Сначало объявляется переменная, потом меняется (в случае с let и var, у const значение не меняется)
var не используется уже. если объявить переменную после смены, то ошибки не будет, но даст undefieted
let в скобках {} выдаёт предупреждение, var нет
Если нужно делать проект для старых браузеров, нужно проверять переменную на https://caniuse.com, старые браузеры поддерживают только var
Существуют специальные технологии, которые переводят новый формат в старый, но это чуть позже 
'use strict'; - директива, которая говорит что мы работаем в современном режиме. Пишется в начале кода 
; ставистя: после объявления переменных (let number = 5;), когда у нас закончился логический блок
( let number = 5;
  const leftBorderWidth = 1;
  number = 10;
  console.log(number); )
  
  alert(5);
  [].push('a');
Нужно следить за этим, т.к. не всегда есть плагины, которые помогут автоматически найти ошибки 

                                          Урок №6 Типы данных

1. Числа

let number = 4.6;

console.log(-4/0); //infinity
console.log('string' * 9); //  Not a number (NaN)

2. Строка

const persone = 'Pavel'; or '5' // Можно писать как текст, так и числа, всё равно будет текст (string)

3. Логический тип данных (boolean)

const bool = true; //or false (правда/неправда).

4. Специфическе null\undefined

console.log(something); - null

let und;
console.log(und); - undefined. Создается пустой ящик, где ничего нет.

-------------------Комплексные данные---------------------------------
5. Объект (коллекция данних, структура, которая используется для хранения любых данных)

const obj = {
    name: 'John',
    age: 25,
    isMarried: false
};                     Всё что внутри {} - свойства объекта и действия (методы)



Как найти свойство, например name ?


const obj = {
    name: 'John',
    age: 25,
    isMarried: false
};

// console.log(obj.name);
console.log(obj.name);

или

const obj = {
    name: 'John',
    age: 25,
    isMarried: false
};

// console.log(obj.name);
console.log(obj ['name']);

Объекты - ключевая единица javascript

6. Массив
Является ли массив отдельным типом данных ? Нет. Это частный случай объекта.
Используется для хранения данных, которые идут строго по порядку.
let arr = ['plum.png', 'orange.jpg', 6, 'apple.bmp', {}, []];

В программировании нумерация начинается с нуля (0).

Массив похож на объект, но тут всё идёт по порядку.

                                     Урок №7. Взаимодействие с пользователем на сайте.

Как вывести окно ? - alert ('Hello');

Как спросить о чём-то (да или нет) ? - const result = confirm('Are you here?');

Как спросить о чём-то, чтобы можно было написать ответ ? - const answer = prompt('Вам есть 18?', '18'); (Тип данных - строка).

console.log(typeof(answer)); - проверить на тип данных.

Можно один тип данных преобразовывать в другой. С помощью + (const answer = prompt('Вам есть 18?', '18');) - const answer = +prompt('Вам есть 18?', '18');)

document.write(answers); - заменяет всё на странице. Почти никогда не используется.

console.log(typeof(null)); - выдаст object, а не null. Это ошибка.

const answers = [];

answers[0] = prompt('Как ваше имя?', '');
answers[1] = prompt('Как ваша фамилия', ''); ------ Все такие команды нужно проверять только в браузере, не в консоли
answers[2] = prompt('Сколько Вам лет', '');

console.log(typeof(answers));

                                              Урок №8 Интерполяция (ES6)
Интерполяция - это значит что внутри строки можем вставлять значение переменной.

console.log('https://someurl.com/' + category); - конкотинация строк. Берется один кусок строки и к нему приклеиваится ещё один кусок строки
Получится https://someurl.com/toys
Когда нужно складывать много кусочков через + получается не красиво. Пример:
console.log('https://someurl.com/' + category + '/' + '4');
И чтобы этого не делать был придуман приём интерполяции.
`` - кавычки "бэктики"
Вот как это работает с бэктиками:

const category = 'toys';

console.log(`https://someurl.com/${category}/5`);
Получится:
https://someurl.com/toys/5
ТАК МОЖНО ДЕЛАТЬ ТОЛЬКО С ТАКИМИ КАВЫЧКАМИ ``(БЭКТИКАМИ)

Ещё пример:
const user = 'Pavel';

alert(`Привет, ${user}`);

Если запустим в браузере получится окно "Привет, Pavel".

                                Урок №9. Операторы в JS.                                
9.1. Простые операторы "+, -, *, /".
Особняком стоит знак "+".
Если строку добавить к числу получится всё равно строка.
console.log(4 + ' - object');
Получится:
4 - object
console.log(4 + +' - object');
Получистя:
NaN
console.log(4 + +'5');
Получится:
9
5-ка из строки превратилась в число.
+, который ставится перед 5-кой называется унарным. ( console.log(4 + +'5'); )

9.2 Инкремент и дикремент.
Существуют для сокращения кода. Увеличивают и уменьшают значение на 1.
let incr = 10,
    decr = 10;

incr++;
decr--;

console.log(incr);
console.log(decr);
Получится:
11
9
Либо:
let incr = 10,
    decr = 10;

++incr;
--decr;

console.log(incr);
console.log(decr);
Получится:
11
9
И там и там добавилось +1 и уменьшелось -1.

Чем отличается префиксная форма от поствексной ?
Если операторы ++ и -- ставим перед (++incr; --decr;) значениями, будет префиксная, если после - поствексная (incr++; decr--;).

Когда мы используем инкремент или дикремент в поствексной форме сразу:
console.log(incr++);
console.log(decr--);
Будет:
10
10
Постексная форма возвращает старое значение, а уже потом его увеличивает.
Если префиксная, то наоборот:
11
9
console.log(++incr);
console.log(--decr);

+ который ставится перед чем-то называется унарным плюсом

console.log(5%2); = 1. Взяли 5 и разделили его столько раз на 2, сколько можно было

Если один раз используется знак = то это называется присваивание  console.log(2*4 = 8);
Если ставить два ==, то будет проверка на правильность console.log(2*4 == 8); true
Если три знака ===, то будет строгое сравнение console.log(2*4 === `8`); false console.log(2*4 == 8); true 

&& - оператор и 
|| - оператор или 
Оператор и работает только тогда, когда у нас 2 или больше подопытнах являются правдивыми выражениями. И это правда и это правда.
Оператор или работает только когда, когда один из вариантов будет правдив.

const isChecked = true,
      isClose = true;

console.log(isChecked && isClose);  --  будет true 

const isChecked = true,
      isClose = false;

console.log(isChecked && isClose); -- будет false

const isChecked = true,
      isClose = false;

console.log(isChecked || isClose); -- будет true (один из операторов правдив).

! - оператор отрицания 

const isChecked = false,
      isClose = false;

console.log(isChecked || !isClose); -- будет true (из-за оператора отрицания)

console.log(2 + 2 * 2 != `6`); false (6=6)
console.log(2 + 2 * 2 !== `6`); true (6 числовое не равно 6 буквенным строго по типу. Там число, там текст).

                                        Урок №10 Контроль версий Git и сервис GitHub
Git - программа для создания репозиториев
GitHub - хранилище репозиторриев 
git add -A - добавить все файлы из рабочей папки
git add main.css - добавить определённый файлы
git add *css - добавить все файлы с форматом .css 
git remote add origin https://github.com/Lion4ik22/project.git - подключить сразу на github
git push -u origin main - отправка на сервер (но сейчас вместо master используют main)

                                         Урок №12 Начало практики!
Сделаны задачи в файле praktika.js

                                         Урок №13 Условия
if - если
else - ещё
Тернарный оператор - (num === 50) ? console.log ('Ok') : console.log ('Erorr');
Использовалось 2 оператора ? и :
Тернарный - потому что в его работе участвуют аж 3 аргумента. Это единственный тернарный оператор, который есть в js 
(num === 50) - 1-й аргумент, console.log ('Ok') - 2-й, console.log ('Erorr'); - 3-й.
Есть ещё бинарный аргумент. 4 + 4. Вторая 4 - бинарный аргумент.
И есть унарный аргумент. +'4'; Тут унарный + работает только с одной строкой
Чтобы избегать больших ветвлений типа:
if (num < 49) {
    console.log ('Erorr');
} else  if (num > 100) {
    console.log ('Много');
} else {
    console.log ('Ok');
}
используется конструкция switch.
Нужно запомнить, что конструкция switch всегда идёт на строгое сравнение. Что переменная num = 49.
После каждого case нужно ставить break; Это обязательная ситаксическая конструкция. Она останавливает дальнейшую проверку, если условие выполнилось.
Сам пример:
const num = 50;

switch (num) {
    case 49:
        console.log('Неверно');
        break;
    case 100:
        console.log('Неверно');
        break;
    case 50:
        console.log('В точку!');
        break;
    default:
        console.log('Не в этот раз');
        break;
}
Так же будеи работать и со строками. Проверка на строгое сравнение. Если мы запишем const num = '50'; И все case так эе

                                         Урок №14 Циклы.
Для циклов есть 3 способа. Каждый нужно использовать в зависимости от ситуации.
1-й цикл -  while.
let num = 50;
while (num < 55) {
    console.log(num);
    num++;
}
Обязательно let, а не const.
2-й цикл - do. С помщью него можно сначала заставить наш цикл что-то сделать, а потом уже проверить условия. Если необходимо - выйти из цикла.
let num = 50;
do {
    console.log(num);
    num++; 
}
while (num < 55);
3-й цикл - for. Самый популярный. т.к. мы можем его настроить.
let num = 50;
for (let i = 1; i < 8; i++) {
     console.log (num);
     num++;
}
Нужно быть аккуратным и не аоставить i < 0, тогда будет бесконечный цикл и программа зависнет.
Можно использовать оператор break, он остановит на нужном цикле. Например:
for (let i = 1; i < 10; i++) {
    if (i === 6) {
        break;
    }

     console.log (i);
    
}
Либо же оператор continue. Он позволяет пропустить тот шаг, который нам не нужен. Но при этом не прерывает весь цикл. Например:
for (let i = 1; i < 10; i++) {
    if (i === 6) {
        // break;
        continue;
    }

     console.log (i);
    
}
В консоли пропадёт 6-ка.
                                         Урок №15 Практика №2
                                         // Задача №1
'use strict';

// const numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// for (let i = 0; i < 2; i++) {
//     const a = prompt ('Один из последних просмотренных фильмов?', ''),
//           b = prompt ('На сколько оцените его?', '');

//           personalMovieDB.movies[a] = b;
// }

// console.log(personalMovieDB); 

//Задача №2
// const numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// for (let i = 0; i < 2; i++) {
//     const a = prompt ('Один из последних просмотренных фильмов?', ''),
//           b = prompt ('На сколько оцените его?', '');

//     if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//         personalMovieDB.movies[a] = b;
//         console.log('done');
//     } else {
//         console.log ('error');
//         i--;
//     }   

          
// }

// console.log(personalMovieDB); 
//Задача №3
const numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

for (let i = 0; i < 2; i++) {
    const a = prompt ('Один из последних просмотренных фильмов?', ''),
          b = prompt ('На сколько оцените его?', '');

    if (a != null && b != null && a != '' && b != '' && a.length < 50) {
        personalMovieDB.movies[a] = b;
        console.log('done');
    } else {
        console.log ('error');
        i--;
    }   

          
}

if (personalMovieDB.count < 10) {
    console.log('Просмотрено довольно мало фильмов');
} else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
    console.log ('Вы классический зритель');
} else if (personalMovieDB.count >= 30) {
    console.log ('Вы киноман');
} else {
    console.log ('Произошла ошибка');
}

console.log(personalMovieDB); 

                                         Урок №16 Функции, стрелочные функции (ES6)
Функции - это наши действия в js. Они используют различные типы данных и изменяют информацию так, как мы укажем.
Одна из самых главных вещей функции это её имя. Существует негласное правило, что оно должно быть глаголом с препиской того, над чем выполняется действие.
Так же функции бывают анонимными.
Если у функции нет имени - в дальнейшем мы не сможем к ней обратиться.
Аргументов может быть бесконечное количество. function showFirstMessage(text, agr, num, fwef)
Если объявить переменную внутри функции - то снаружи она уже не доступна.
Переменные созданные при помощи let и const существуют только внутри блока функций.
Переменная созданная внутри функции называется локальной переменной. Т.к. существует только локально внутри функции.
Глобальная переменная создаётся выше функции.
Когда функция вызывается - она пытается найти какие-то значения. Если внутри себя не находит, идёт на уровень выше.
Замыкание функции - это сама функция вместе со всеми внешними переменными, котоыре есть доступны.
Функция - это автоматизация наших процессов.
return позволяет вернуть всё во внешний мир.
Функций бывает 3.
1 - Function Daclaration. Стандартная функция. Особенность в том, что она существует ещё до того, как код запустится. Как переменная var.
2 - Function Expression. Функциональное выражение. Нужно ставить в конце ;
const logger = function() {
    console.log('Hello');
};

logger();
Данная функция создаётся только тогда, когда до неё доходит поток кода. Её можно вызвать только после объявления. Создаётся только тогда, когда до неё доходит код.
3 - Стрелочная функция. Такая функция не имеет контекста вызова. Чаще всего встречается в обработчике событий. Везде использовать её нельзя.
const calc = (a, b) => a + b;
Или:
const calc = (a, b) => {
    console.log('1');
    return a + b;
}; 
Функция - это один из оснополагающих кирпичиков любой программы.