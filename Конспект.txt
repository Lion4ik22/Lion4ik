Прямых констант (const) в javascript не бывает
Сначало объявляется переменная, потом меняется (в случае с let и var, у const значение не меняется)
var не используется уже. если объявить переменную после смены, то ошибки не будет, но даст undefieted
let в скобках {} выдаёт предупреждение, var нет
Если нужно делать проект для старых браузеров, нужно проверять переменную на https://caniuse.com, старые браузеры поддерживают только var
Существуют специальные технологии, которые переводят новый формат в старый, но это чуть позже 
'use strict'; - директива, которая говорит что мы работаем в современном режиме. Пишется в начале кода 
; ставистя: после объявления переменных (let number = 5;), когда у нас закончился логический блок
( let number = 5;
  const leftBorderWidth = 1;
  number = 10;
  console.log(number); )
  
  alert(5);
  [].push('a');
Нужно следить за этим, т.к. не всегда есть плагины, которые помогут автоматически найти ошибки 

                                          Урок №6 Типы данных

1. Числа

let number = 4.6;

console.log(-4/0); //infinity
console.log('string' * 9); //  Not a number (NaN)

2. Строка

const persone = 'Pavel'; or '5' // Можно писать как текст, так и числа, всё равно будет текст (string)

3. Логический тип данных (boolean)

const bool = true; //or false (правда/неправда).

4. Специфическе null\undefined

console.log(something); - null

let und;
console.log(und); - undefined. Создается пустой ящик, где ничего нет.

-------------------Комплексные данные---------------------------------
5. Объект (коллекция данних, структура, которая используется для хранения любых данных)

const obj = {
    name: 'John',
    age: 25,
    isMarried: false
};                     Всё что внутри {} - свойства объекта и действия (методы)



Как найти свойство, например name ?


const obj = {
    name: 'John',
    age: 25,
    isMarried: false
};

// console.log(obj.name);
console.log(obj.name);

или

const obj = {
    name: 'John',
    age: 25,
    isMarried: false
};

// console.log(obj.name);
console.log(obj ['name']);

Объекты - ключевая единица javascript

6. Массив
Является ли массив отдельным типом данных ? Нет. Это частный случай объекта.
Используется для хранения данных, которые идут строго по порядку.
let arr = ['plum.png', 'orange.jpg', 6, 'apple.bmp', {}, []];

В программировании нумерация начинается с нуля (0).

Массив похож на объект, но тут всё идёт по порядку.

                                     Урок №7. Взаимодействие с пользователем на сайте.

Как вывести окно ? - alert ('Hello');

Как спросить о чём-то (да или нет) ? - const result = confirm('Are you here?');

Как спросить о чём-то, чтобы можно было написать ответ ? - const answer = prompt('Вам есть 18?', '18'); (Тип данных - строка).

console.log(typeof(answer)); - проверить на тип данных.

Можно один тип данных преобразовывать в другой. С помощью + (const answer = prompt('Вам есть 18?', '18');) - const answer = +prompt('Вам есть 18?', '18');)

document.write(answers); - заменяет всё на странице. Почти никогда не используется.

console.log(typeof(null)); - выдаст object, а не null. Это ошибка.

const answers = [];

answers[0] = prompt('Как ваше имя?', '');
answers[1] = prompt('Как ваша фамилия', ''); ------ Все такие команды нужно проверять только в браузере, не в консоли
answers[2] = prompt('Сколько Вам лет', '');

console.log(typeof(answers));

                                              Урок №8 Интерполяция (ES6)
Интерполяция - это значит что внутри строки можем вставлять значение переменной.

console.log('https://someurl.com/' + category); - конкотинация строк. Берется один кусок строки и к нему приклеиваится ещё один кусок строки
Получится https://someurl.com/toys
Когда нужно складывать много кусочков через + получается не красиво. Пример:
console.log('https://someurl.com/' + category + '/' + '4');
И чтобы этого не делать был придуман приём интерполяции.
`` - кавычки "бэктики"
Вот как это работает с бэктиками:

const category = 'toys';

console.log(`https://someurl.com/${category}/5`);
Получится:
https://someurl.com/toys/5
ТАК МОЖНО ДЕЛАТЬ ТОЛЬКО С ТАКИМИ КАВЫЧКАМИ ``(БЭКТИКАМИ)

Ещё пример:
const user = 'Pavel';

alert(`Привет, ${user}`);

Если запустим в браузере получится окно "Привет, Pavel".

                                Урок №9. Операторы в JS.                                
9.1. Простые операторы "+, -, *, /".
Особняком стоит знак "+".
Если строку добавить к числу получится всё равно строка.
console.log(4 + ' - object');
Получится:
4 - object
console.log(4 + +' - object');
Получистя:
NaN
console.log(4 + +'5');
Получится:
9
5-ка из строки превратилась в число.
+, который ставится перед 5-кой называется унарным. ( console.log(4 + +'5'); )

9.2 Инкремент и дикремент.
Существуют для сокращения кода. Увеличивают и уменьшают значение на 1.
let incr = 10,
    decr = 10;

incr++;
decr--;

console.log(incr);
console.log(decr);
Получится:
11
9
Либо:
let incr = 10,
    decr = 10;

++incr;
--decr;

console.log(incr);
console.log(decr);
Получится:
11
9
И там и там добавилось +1 и уменьшелось -1.

Чем отличается префиксная форма от поствексной ?
Если операторы ++ и -- ставим перед (++incr; --decr;) значениями, будет префиксная, если после - поствексная (incr++; decr--;).

Когда мы используем инкремент или дикремент в поствексной форме сразу:
console.log(incr++);
console.log(decr--);
Будет:
10
10
Постексная форма возвращает старое значение, а уже потом его увеличивает.
Если префиксная, то наоборот:
11
9
console.log(++incr);
console.log(--decr);

+ который ставится перед чем-то называется унарным плюсом

console.log(5%2); = 1. Взяли 5 и разделили его столько раз на 2, сколько можно было

Если один раз используется знак = то это называется присваивание  console.log(2*4 = 8);
Если ставить два ==, то будет проверка на правильность console.log(2*4 == 8); true
Если три знака ===, то будет строгое сравнение console.log(2*4 === `8`); false console.log(2*4 == 8); true 

&& - оператор и 
|| - оператор или 
Оператор и работает только тогда, когда у нас 2 или больше подопытнах являются правдивыми выражениями. И это правда и это правда.
Оператор или работает только когда, когда один из вариантов будет правдив.

const isChecked = true,
      isClose = true;

console.log(isChecked && isClose);  --  будет true 

const isChecked = true,
      isClose = false;

console.log(isChecked && isClose); -- будет false

const isChecked = true,
      isClose = false;

console.log(isChecked || isClose); -- будет true (один из операторов правдив).

! - оператор отрицания 

const isChecked = false,
      isClose = false;

console.log(isChecked || !isClose); -- будет true (из-за оператора отрицания)

console.log(2 + 2 * 2 != `6`); false (6=6)
console.log(2 + 2 * 2 !== `6`); true (6 числовое не равно 6 буквенным строго по типу. Там число, там текст).

                                        Урок №10 Контроль версий Git и сервис GitHub
Git - программа для создания репозиториев
GitHub - хранилище репозиторриев 
git add -A - добавить все файлы из рабочей папки
git add main.css - добавить определённый файлы
git add *css - добавить все файлы с форматом .css 
git remote add origin https://github.com/Lion4ik22/project.git - подключить сразу на github
git push -u origin main - отправка на сервер (но сейчас вместо master используют main)

                                         Урок №12 Начало практики!
Сделаны задачи в файле praktika.js

                                         Урок №13 Условия
if - если
else - ещё
Тернарный оператор - (num === 50) ? console.log ('Ok') : console.log ('Erorr');
Использовалось 2 оператора ? и :
Тернарный - потому что в его работе участвуют аж 3 аргумента. Это единственный тернарный оператор, который есть в js 
(num === 50) - 1-й аргумент, console.log ('Ok') - 2-й, console.log ('Erorr'); - 3-й.
Есть ещё бинарный аргумент. 4 + 4. Вторая 4 - бинарный аргумент.
И есть унарный аргумент. +'4'; Тут унарный + работает только с одной строкой
Чтобы избегать больших ветвлений типа:
if (num < 49) {
    console.log ('Erorr');
} else  if (num > 100) {
    console.log ('Много');
} else {
    console.log ('Ok');
}
используется конструкция switch.
Нужно запомнить, что конструкция switch всегда идёт на строгое сравнение. Что переменная num = 49.
После каждого case нужно ставить break; Это обязательная ситаксическая конструкция. Она останавливает дальнейшую проверку, если условие выполнилось.
Сам пример:
const num = 50;

switch (num) {
    case 49:
        console.log('Неверно');
        break;
    case 100:
        console.log('Неверно');
        break;
    case 50:
        console.log('В точку!');
        break;
    default:
        console.log('Не в этот раз');
        break;
}
Так же будеи работать и со строками. Проверка на строгое сравнение. Если мы запишем const num = '50'; И все case так эе

                                         Урок №14 Циклы.
Для циклов есть 3 способа. Каждый нужно использовать в зависимости от ситуации.
1-й цикл -  while.
let num = 50;
while (num < 55) {
    console.log(num);
    num++;
}
Обязательно let, а не const.
2-й цикл - do. С помщью него можно сначала заставить наш цикл что-то сделать, а потом уже проверить условия. Если необходимо - выйти из цикла.
let num = 50;
do {
    console.log(num);
    num++; 
}
while (num < 55);
3-й цикл - for. Самый популярный. т.к. мы можем его настроить.
let num = 50;
for (let i = 1; i < 8; i++) {
     console.log (num);
     num++;
}
Нужно быть аккуратным и не аоставить i < 0, тогда будет бесконечный цикл и программа зависнет.
Можно использовать оператор break, он остановит на нужном цикле. Например:
for (let i = 1; i < 10; i++) {
    if (i === 6) {
        break;
    }

     console.log (i);
    
}
Либо же оператор continue. Он позволяет пропустить тот шаг, который нам не нужен. Но при этом не прерывает весь цикл. Например:
for (let i = 1; i < 10; i++) {
    if (i === 6) {
        // break;
        continue;
    }

     console.log (i);
    
}
В консоли пропадёт 6-ка.
                                         Урок №15 Практика №2
                                         // Задача №1
'use strict';

// const numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// for (let i = 0; i < 2; i++) {
//     const a = prompt ('Один из последних просмотренных фильмов?', ''),
//           b = prompt ('На сколько оцените его?', '');

//           personalMovieDB.movies[a] = b;
// }

// console.log(personalMovieDB); 

//Задача №2
// const numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// for (let i = 0; i < 2; i++) {
//     const a = prompt ('Один из последних просмотренных фильмов?', ''),
//           b = prompt ('На сколько оцените его?', '');

//     if (a != null && b != null && a != '' && b != '' && a.length < 50) {
//         personalMovieDB.movies[a] = b;
//         console.log('done');
//     } else {
//         console.log ('error');
//         i--;
//     }   

          
// }

// console.log(personalMovieDB); 
//Задача №3
const numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

for (let i = 0; i < 2; i++) {
    const a = prompt ('Один из последних просмотренных фильмов?', ''),
          b = prompt ('На сколько оцените его?', '');

    if (a != null && b != null && a != '' && b != '' && a.length < 50) {
        personalMovieDB.movies[a] = b;
        console.log('done');
    } else {
        console.log ('error');
        i--;
    }   

          
}

if (personalMovieDB.count < 10) {
    console.log('Просмотрено довольно мало фильмов');
} else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
    console.log ('Вы классический зритель');
} else if (personalMovieDB.count >= 30) {
    console.log ('Вы киноман');
} else {
    console.log ('Произошла ошибка');
}

console.log(personalMovieDB); 

                                         Урок №16 Функции, стрелочные функции (ES6)
Функции - это наши действия в js. Они используют различные типы данных и изменяют информацию так, как мы укажем.
Одна из самых главных вещей функции это её имя. Существует негласное правило, что оно должно быть глаголом с препиской того, над чем выполняется действие.
Так же функции бывают анонимными.
Если у функции нет имени - в дальнейшем мы не сможем к ней обратиться.
Аргументов может быть бесконечное количество. function showFirstMessage(text, agr, num, fwef)
Если объявить переменную внутри функции - то снаружи она уже не доступна.
Переменные созданные при помощи let и const существуют только внутри блока функций.
Переменная созданная внутри функции называется локальной переменной. Т.к. существует только локально внутри функции.
Глобальная переменная создаётся выше функции.
Когда функция вызывается - она пытается найти какие-то значения. Если внутри себя не находит, идёт на уровень выше.
Замыкание функции - это сама функция вместе со всеми внешними переменными, котоыре есть доступны.
Функция - это автоматизация наших процессов.
return позволяет вернуть всё во внешний мир.
Функций бывает 3.
1 - Function Daclaration. Стандартная функция. Особенность в том, что она существует ещё до того, как код запустится. Как переменная var.
2 - Function Expression. Функциональное выражение. Нужно ставить в конце ;
const logger = function() {
    console.log('Hello');
};

logger();
Данная функция создаётся только тогда, когда до неё доходит поток кода. Её можно вызвать только после объявления. Создаётся только тогда, когда до неё доходит код.
3 - Стрелочная функция. Такая функция не имеет контекста вызова. Чаще всего встречается в обработчике событий. Везде использовать её нельзя.
const calc = (a, b) => a + b;
Или:
const calc = (a, b) => {
    console.log('1');
    return a + b;
}; 
Функция - это один из оснополагающих кирпичиков любой программы.

                                         Урок №17 Методы и свойства строк и чисел
Методы - это вспомогательные функции.
Свойства - это вспомогательные значения.
После метода должны стоять (), кроме length.
console.log(fruit.indexOf('fruit'));
Например свойство length. Используется для того, чтобы получить длину как строки, так и других типов данных.
const str = 'test';
const arr = [1, 2, 4];

console.log(arr.length);
Ответ будет 3, т.к. в массиве 3 элемента.

Или пример:
const str = 'test';
const arr = [1, 2, 4];

console.log(str[2]);
Ответ будет s, т.к. это 3-й символ с слвое test. Нумерация начинается с 0.

Новички тут пытаются поменять символ на свой. Например:
const str = 'test';
const arr = [1, 2, 4];

console.log(str[2]);
Ответ будет d и test. Т.е. данный способ не работает.

Свойство toUpperCase. Меняет регистр букв. С маленького на большой.
const str = 'test';

// console.log(str[2] = 'd');

console.log(str.toUpperCase());
console.log(str);
Ответ: TEST и test.
Это свойство вызывает новое значение, поэтому в ответе их два.

Метод toLowerCase делает наоборот. Превращает в маленький.
const str = 'teSt';

// console.log(str[2] = 'd');

// console.log(str.toUpperCase());
console.log(str.toLowerCase());
console.log(str);
Ответ: test и test.

Слудующий метод позволяет найти кусочек нашей строки и сказать с какого индекса (с какой позиции) она начинается.
Метод indexOf
const fruit = 'Some fruit';

console.log(fruit.indexOf('fruit'));
Ответ: 5.
Если записать
const fruit = 'Some fruit';

console.log(fruit.indexOf('q'));
Ответ: -1. Это значит, что такая буква или такой кусочек строки у нас вообще не был найден.
Называется этот метод ещё "Поиск под строки".

Остался не закрытый вопрос. Если строка не изменяема, то как мы можем её модифицировать и вообещ как-то поменять ?
Есть 3 метода, которые вот так взаимодействуют со строками.
1-й метод - slice.

const logg = 'Hello world';

console.log(logg.slice(6, 11));
Ответ: world. Мы вырезали это слово.
Но есть особенность. Если мы сделаем так:

const logg = 'Hello world';

console.log(logg.slice(6, 11));
То ответ будет: worl
Потому что когда мы используем slice мы в аргументе and указываем то, что не включается. До какого-то момента, но не включая.
const logg = 'Chelsea football club';

console.log(logg.slice(7, 16));
Ответ: football
Есть ещё одно использование метода slice.
const logg = 'Hello world';

console.log(logg.slice(6));
Ответ: 6. Можно указать только первый аргумент, с чего начинать. И это значит, что наша строка будет вырезаться просто до конца.
Так же этот метод поддерживает отрицательные значения. Тогда они будет начинаться с конца строки.
const logg = 'Hello world';

console.log(logg.slice(-5, -1));
Ответ: worl

2-й метод - substring.
Он так же принимает аргументы start и and.
Метод очень похож не 1-й. Разница лишь в том, что тут можно задавать первый аргумент больше, чем второй. И он не поддерживает отрицательные значения.
const logg = 'Hello world';

console.log(logg.substring(6, 11));
Ответ: world.

3-й метод - substr.
Главное отличите, то что здесь вместо второго аргумента конца мы указываем длину. Сколько символов нам необходимо вырезать.
const logg = 'Hello world';

console.log(logg.substring(6, 11));
Ответ: world.
Этот метод просто говорит, сколько символов вырезать.

Теперь методы чисел.
Для работы с числами в js есть отдельная мини библиотека, которая существует прям внутри браузера. Прямо внутри js.
Называется она - Math. Есть разные (cos, sin, максимальное значение и т.д.)
Остановимся на округлении.
const num = 12.2;
console.log(Math.round(num));
Ответ: 12. Число округлилось до ближайшего целого.

В самих числах есть интересные методы, благодаря которым мы можем преобразовывать строки в числа. Хотя истенное предназначение у этих методов совершенно другое.
Например метод parseInt. 
Этот метод вызывается на числах. Он занимается тем, что переводит число в другую систему исчесления.
const test = '12.2px';
console.log(parseInt(test));
Ответ: 12. И это уже числовой тип данных.

Ещё один метод - parseFloat.
Он служит, чтобы взять какое-то число либо строку и вернуть нам в десятичном варианте.
const test = '12.2px';
console.log(parseFloat(test));
Ответ: 12.2.


                                         Урок №18 Практика №3. Используем функции.
Задача №1
'use strict';

let numberOfFilms;


function start() {
    numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');

    while (numberOfFilms == '' || numberOfFilms == null || isNaN(numberOfFilms)) {
        numberOfFilms  = +prompt('Сколько фильмов вы уже просмотрели?', '');
    }
}

start();


const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    privat: false
};


function rememberMyFilms() {
    for (let i = 0; i < 2; i++) {
        const a = prompt ('Один из последних просмотренных фильмов?', ''),
              b = prompt ('На сколько оцените его?', '');
    
        if (a != null && b != null && a != '' && b != '' && a.length < 50) {
            personalMovieDB.movies[a] = b;
            console.log('done');
        } else {
            console.log ('error');
            i--;
        }   
    
              
    }
}

rememberMyFilms();



function detectPersonalLevel() {
    if (personalMovieDB.count < 10) {
        console.log('Просмотрено довольно мало фильмов');
    } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
        console.log ('Вы классический зритель');
    } else if (personalMovieDB.count >= 30) {
        console.log ('Вы киноман');
    } else {
        console.log ('Произошла ошибка');
    }
}

detectPersonalLevel();

console.log(personalMovieDB); 

Задача №2
function showMyDB(hidden) {
    if (!hidden) {
        console.log(personalMovieDB); 
    }
}

showMyDB(personalMovieDB.privat);

Задача №3.
function writeYourGenres() {
    for (let i = 1; i <= 3; i++) {
    const genre = prompt (`Ваш любимый жанр под номером ${i}`);
    personalMovieDB.genres[i - 1] = genre;
    }
}

writeYourGenres();

Или такой вариант:
function writeYourGenres() {
    for (let i = 1; i <= 3; i++) {
    personalMovieDB.genres[i - 1] = prompt (`Ваш любимый жанр под номером ${i}`);
    }
}

writeYourGenres();

                                         Урок №19 Callback - функции
Главное правило функции - если функции идут в коде одна за другой, это не значит, что они выполняются в такой же последовательности
Пример функции задержки:
function first() {
    // Do something
    setTimeout(function() {
        console.log(1);
    }, 500);
}

function second() {
    console.log(2);
}

first();
second();
В консоль выведет 2, а потом 1. Т.к. есть задержка в 500 мск.

Что такое Callback - это функция, которая должна быть выполнена после того, как другая функция завершила своё выполнение.
Пример:
function learnJS(lang, callback) {
    console.log(`Я учу: ${lang}`);
    callback();
}

learnJS('JavaScript', function() {
    console.log('Я прошёл этот урок!');
});
Ответ: 
Я учу: JavaScript
Я прошёл этот урок!
Таким образом должна соблюдаться последовательность функций.

Или вариант без анонимной функции:
function learnJS(lang, callback) {
    console.log(`Я учу: ${lang}`);
    callback();
}

function done() {
    console.log('Я прошёл этот урок!');
}

learnJS('JavaScript', done);
Ответ:
Я учу: JavaScript
Я прошёл этот урок!

Итог: Callback позволяет нам быть увереным в том, что определённый код не начнёт исполнение до того момента, пока другой код не завершит своё исполнение.   

                                         Урок №20 Объекты, деструктуризация объектов (ES6)
Как удалить свойство из объекта ?
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(options.name);

delete options.name;

console.log(options);
Ответ:
test
{ width: 1024, height: 1024, colors: { border: 'black', bg: 'red' } }
Хоть мы работаем с константой, но при этом объект, который находится внутри мы модифицируем по собстенному желанию.

Прямых констант в js не существет.

Как перебрать свойства объекта ?
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

// console.log(options.name);

// delete options.name;

// console.log(options);

for (let key in options) {
    console.log(`Свойство ${key} имеет значение ${options[key]}`);
}
Ответ:
Свойство name имеет значение test
Свойство width имеет значение 1024
Свойство height имеет значение 1024
Свойство colors имеет значение [object Object]

Кроме способа перебора for in есть ещё способ перебора for of. Но для объекта он работать не будет.
Пример:
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

// console.log(options.name);

// delete options.name;

// console.log(options);

for (let key of options) {
    console.log(`Свойство ${key} имеет значение ${options[key]}`);
}
Ответ: Ошибка. options is not iterable

Что такое Свойство colors имеет значение [object Object] ?
Это объект внутри объекта. С таким нужно уметь работать.

Как получить свойство объекта внутри объекта ? (Просто пример).
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(options ['colors'] ['border']);
Ответ: black.

Или пример сложнее:
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(options ['colors'] ['border']);

// delete options.name;

// console.log(options);

for (let key in options) {
    if (typeof(options[key]) === 'object') {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key] [i]}`); 
        }
    }
    else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
    }
}
Ответ:
black
Свойство name имеет значение test
Свойство width имеет значение 1024
Свойство height имеет значение 1024
Свойство border имеет значение black
Свойство bg имеет значение red

Функции и методы, которые есть внутри объекта.

Приём счетчика.
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(options ['colors'] ['border']);

// delete options.name;

// console.log(options);

let counter = 0;

for (let key in options) {
    if (typeof(options[key]) === 'object') {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key] [i]}`); 
            counter++;
        }
    }
    else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++;
    }
}
console.log(counter);
Ответ:
black
Свойство name имеет значение test
Свойство width имеет значение 1024
Свойство height имеет значение 1024
Свойство border имеет значение black
Свойство bg имеет значение red
5

Либо же мы хотим получить только на самом верхнем уровне, то нужно оставить counter++ только в одном месте:
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(options ['colors'] ['border']);

// delete options.name;

// console.log(options);

let counter = 0;

for (let key in options) {
    if (typeof(options[key]) === 'object') {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key] [i]}`); 
        }
    }
    else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++;
    }
}
console.log(counter);
Ответ:
black
Свойство name имеет значение test
Свойство width имеет значение 1024
Свойство height имеет значение 1024
Свойство border имеет значение black
Свойство bg имеет значение red
3
Почему 3 ? Потому что когда мы наткнулись на colors здесь уже пошёл объект и у нас условие пошло по другой вилке.
Классический метод того, чтобы узнать какое количество свойств находится в объекте:
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

// console.log(options ['colors'] ['border']);

// delete options.name;

// console.log(options);

let counter = 0;

for (let key in options) {
    // if (typeof(options[key]) === 'object') {
    //     for (let i in options[key]) {
    //         console.log(`Свойство ${i} имеет значение ${options[key] [i]}`); 
    //     }
    // }
    // else {
    //     console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++;
    // }
}
console.log(counter);
Ответ:4

Переходим к методам, которые используются у объектов.

Первый метод Object,keys 
Этот метод берёт наш объект и на его основании создаёт массив в котором все элементы это ключи находящиеся на первой части пары ключ значений у объектов.
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(Object.keys(options));
Ответ: [ 'name', 'width', 'height', 'colors' ]

Нужно вспомнить что у строк и у массивов есть свойство lenght. Которое можно использовать для того, чтобы узнать какое количество элементов там содержится.
Пример:
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    }
};

console.log(Object.keys(options).length);
Ответ: 4.

Так же мы можем создавать такие методы вручную.
Методы - это действия, которые может совершать наш объект.
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    },
    makeTest: function() {
        console.log('Test');
    }
};

options.makeTest();

Объекты - это структуры, которые могут сохранять в себе абсолютно любые типы данных в формате ключ:значение.
Они так же могут быть вложенные. Объекты в объекты, массивы в объекты и т.д.
Чтобы их перебрать мы можем использовать такую конструкцию как for in. И внутри делать всё что угодно как с ключами, так и со значениями этих ключей.
Получать обычные свойства мы можем либо через точку, либо через квадратные [] скобки.
У объектов бывают встроенные методы и свойства. 
Для того, чтобы объект наш умел что-то делать, мы можем во внутрь него записывать функции. И таким образом мы будем создавать методы нашего объекта.

Деструктуризация объекта.
Мы будем вытаскиывать переменные в качестве отдельных структур.
Пример:
const {border, bg} = options.colors;
Мы вытащили кусочки (свойства (border, bg)), которые находятся во вложенном объекте в качестве отдельной переменной.
Пример наглядный:
const options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black', 
        bg: 'red'
    },
    makeTest: function() {
        console.log('Test');
    }
};

options.makeTest();

const {border, bg} = options.colors;
console.log(border);
Ответ: Test и black.

Всё, что существует в js идёт от объектов.
JavaScript считается объектно-ориентированным языком и все сущности которые в нём есть сводятся к объектам.
Либо правильнее назвать js прототипно-ориентированным.

                                         Урок №21 Массивы и псевдомассивы

1-й метод - arr.pop();
Он удаляет последние элементы из нашего массива.
Пример:
const arr = [1, 2, 3, 6, 8];

arr.pop();

console.log(arr);
Ответ: [ 1, 2, 3, 6 ]     

2-й метод arr.push();
Он добавляет какой-то элемент в конце массива.
Пример:
const arr = [1, 2, 3, 6, 8];

// arr.pop();
arr.push(10)

console.log(arr);
Ответ: [ 1, 2, 3, 6, 8, 10 ]

Конструкция перебора for of.
const arr = [1, 2, 3, 6, 8];

// arr.pop();
// arr.push(10)

// console.log(arr);

// for (let i = 0; i < arr.length; i++) {
//     console.log(arr[i]);
// }

for (let value of arr) {
    console.log(value);
}
Ответ:
1
2
3
6
8
Такая конструкция работает только с массивоподобными сущностями. В других случаях нужно использовать цикл.

На собеседовании могут спросить такой вопрос:
Как соотносится между собой свойство length и порядковые номера внутри элементов у этих массивов ?
Ответ: length свойство состоит из последнего(!) индекса, который есть у нас в массиве +1.

3-й метод forEach
Пример:
const arr = [1, 2, 3, 6, 8];
// arr[99] = 0;
// console.log(arr.length);
// console.log(arr);

arr.forEach(function(item, i, arr) {
    console.log(`${i}: ${item} внутри массива ${arr}`);
});
Ответ:
0: 1 внутри массива 1,2,3,6,8
1: 2 внутри массива 1,2,3,6,8
2: 3 внутри массива 1,2,3,6,8
3: 6 внутри массива 1,2,3,6,8
4: 8 внутри массива 1,2,3,6,8

Когда использовать метод forEach, а когда можно использовать обычный цикл или перебор при помощи for of ?
Обычно программисты используют метод forEach во всех подобных задачах. Но у метода for of есть один плюс.
То что мы здесь можем использовать такие ключевые слова как break и continue. Т.е. мы сможем остановить цикл на каком-то этапе.
А у метода forEach это сделать невозможно.

4-й метод - split
Этот метод помогает сформировать из той строки, который мы ввели в prompt массив.
Пример (будет работать только внутри браузера):
const str = prompt('', '');
const products = str.split(', ');
console.log(products);
Ответ:
(4) ["qqq", "www", "eee", "rrr"]
0: "qqq"
1: "www"
2: "eee"
3: "rrr"
length: 4
__proto__: Array(0)

5-й метод - join.
Обратная операция 4-му методу. Когда мы на основании массива можем сформировать большую строку.
const str = prompt('', '');
const products = str.split(', ');
console.log(products.join('; '));
Ответ: qqq; www; eee; rrr

6-й метод (метод сортировки) - sort.
const str = prompt('', '');
const products = str.split(', ');
products.sort();
console.log(products).join('; ');
Ответ:
0: "bbb"
1: "ddd"
2: "qqq"
Этот метод всегда сортирует элементы которые находятся внутри массива как строки.
На примере с цифрами это не сработает:
const arr = [2, 13, 26, 8, 10];
arr.sort();
console.log(arr);
Ответ: [10, 13, 2, 26, 8]

Но и их можно отсортировать так, как нужно. Например по порядку. Использую функцию.
Пример:
const arr = [2, 13, 26, 8, 10];
arr.sort(compareNum);
console.log(arr);

function compareNum(a, b) {
    return a - b;
}
Ответ: [2, 8, 10, 13, 26]

Это произошло из-за того, что метод sort внутри себя использует один из алгоритмов, который называется алгоритм быстрой сортировки.

Псевдомассив.
У псевдомассивов не будет вообще никаких методов (forEach, filtr, push, join и т.д).
Это просто структура, которая хранит данные по порядку.

                                         Урок №22 Передача по ссылке или по значению, Spread оператор (ES6-ES9)
let a = 5,
    b = a;

b = b + 5;

console.log(b);
console.log(a);
Ответ: 
10
5

const obj = {
    a: 5,
    b: 1
};

const copy = obj;

copy.a = 10;

console.log(copy);
console.log(obj);
Ответ:
{ a: 10, b: 1 }
{ a: 10, b: 1 }

Почему так произошло ?
Потому что в const copy = obj; не кладётся какой-то новый объект который похож или идентичен структуре внутри. Здесь передаётся значенеи по ссылке.
Эта запись означает, что она передаёт не саму структуру объекта, а именно ссылку.
В переменную copy кладётся ссылка на уже существуюший объект.
И так получается, что мы модифицируя копию мы модифицируем наш изначальный объект.
Потому что мы работаем не с копией этого объекта, а именно ссылкой на предыдущую структуру.
И такое поведение называется "Передача по ссылке".

Как же тогда создавать копии объектов, массивов и т.д ?
Для этого существует несколько способов.

1-й способ - использование цикла.
Создадим функцию, которая будет при помощи цикла создавать новый объект уже перебирая старые свойства, которые уже были в нашем объекте.
Пример:
function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj [key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
}

const newNumbers = copy(numbers);

newNumbers.a = 10;

console.log(newNumbers);
console.log(numbers);

Ответ:
{ a: 10, b: 5, c: { x: 7, y: 4 } }
{ a: 2, b: 5, c: { x: 7, y: 4 } }

Если к примеру выше добавить newNumbers.c.x = 10; и вывести в консоль результат, то ответ будет:
{ a: 10, b: 5, c: { x: 10, y: 4 } }
{ a: 2, b: 5, c: { x: 10, y: 4 } }
Т.е. x поменялся сразу в обоих местах.
Нужно запомнить, что когда мы клонируем так объекты есть два очень важных понятия.
Это глубокие и поверхонстные копии объектов.
Сейчас мы создали поверхностную копию. Потому что она берёт все обычные свойства, которые были в родителе и создаёт как бы независимую структуру.
Но когда появляется вложенная структура, например одно из свойств будет содержать объект, массив и т.д. То это свойство опять же будет иметь ссылочный тип данных.
Т.е. где мы в newNumbers обратились к c, мы на самом деле обратились к объекту
    c: {
        x: 7,
        y: 4
    }
Потому что там сохранилась на него ссылка.
Это и называется поверхностная копия объекта.

2-й способ - Object.assign
Он позвоялет соеденить сразу несколько объектов.
Пример:
'use strict';

// let a = 5,
//     b = a;

// b = b + 5;

// console.log(b);
// console.log(a);

// const obj = {
//     a: 5,
//     b: 1
// };

// const copy = obj; // Передаёт ссылку

// copy.a = 10;

// console.log(copy);
// console.log(obj);

function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj [key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
}

const newNumbers = copy(numbers);

newNumbers.a = 10;
newNumbers.c.x = 10;

console.log(newNumbers);
console.log(numbers);

const add = {
    d: 17,
    e: 20
};

console.log(Object.assign(numbers, add));
Ответ:
{ a: 10, b: 5, c: { x: 10, y: 4 } }
{ a: 2, b: 5, c: { x: 10, y: 4 } }
{ a: 2, b: 5, c: { x: 10, y: 4 }, d: 17, e: 20 }
Итого 2 объекта у нас соеденились.
И сейчас мы создали независимую, поверхонстную копию объекта.

Или пример:
'use strict';

// let a = 5,
//     b = a;

// b = b + 5;

// console.log(b);
// console.log(a);

// const obj = {
//     a: 5,
//     b: 1
// };

// const copy = obj; // Передаёт ссылку

// copy.a = 10;

// console.log(copy);
// console.log(obj);

function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj [key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
}

const newNumbers = copy(numbers);

newNumbers.a = 10;
newNumbers.c.x = 10;

// console.log(newNumbers);
// console.log(numbers);

const add = {
    d: 17,
    e: 20
};

const clone = (Object.assign({}, add));

clone.d = 20;

console.log(add);
console.log(clone); 
Ответ:
{ d: 17, e: 20 }
{ d: 20, e: 20 }
Тут мы создали пустой объект и присоединили к нему другой.

3-й метод. 
Как создать поверхонстную копию в массивах ?
'use strict';

// let a = 5,
//     b = a;

// b = b + 5;

// console.log(b);
// console.log(a);

// const obj = {
//     a: 5,
//     b: 1
// };

// const copy = obj; // Передаёт ссылку

// copy.a = 10;

// console.log(copy);
// console.log(obj);

function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj [key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
}

const newNumbers = copy(numbers);

newNumbers.a = 10;
newNumbers.c.x = 10;

// console.log(newNumbers);
// console.log(numbers);

const add = {
    d: 17,
    e: 20
};

const clone = (Object.assign({}, add));

clone.d = 20;

// console.log(add);
// console.log(clone); 

const oldArray = ['a', 'b', 'c'];
const newArray = oldArray.slice();

newArray[1] = 'asdasda';
console.log(newArray);
console.log(oldArray);
Ответ:
[ 'a', 'asdasda', 'c' ]
[ 'a', 'b', 'c' ]

4-й способ - использование оператора разворота.

const video = ['youtube', 'vimeo', 'rutube'],
      blogs = ['wordpress', 'livejournal', 'blogger'],
      internet = [...video, ...blogs, 'vk', 'facebook'];

      console.log(internet);
Ответ:
[
  'youtube',
  'vimeo',
  'rutube',
  'wordpress',
  'livejournal',
  'blogger',
  'vk',
  'facebook'
]

Или пример посложнее.
function log(a, b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

const num = [2, 5, 7];

log(...num);
Ответ:
2
5
7

5-й способ - спрэй оператор
const array = ['a', 'b'];

const newAarray = [...array];

const q = {
    one: 1,
    two: 2
}

const newObj = {...q};

                                         Урок №23 Основы ООП(объектно-ориентированное программирование), прототипно-ориентированное наследование
Смысл ООП в том, что мы представляем любую вещь как объект. С набором свойств методов.

let str = 'some';
let strObj = new String(str);

console.log(typeof(str));
console.log(typeof(strObj));
Ответ:
string (строка)
object (объект)

Любые конструкции прототипно у нас наследуются от объекта.

Как создать прототип объекта.
1-й способ (устаревший):

const soldier = {
    health: 400,
    armor: 100
};

const john = {
    health: 100
};

john.__proto__ = soldier;

console.log(john.armor);
Ответ: 100

2-й способ (актуальный). Устанавливаем прототив от john до soldier:
const soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log('Hello');
    }
};

const john = {
    health: 100
};

// john.__proto__ = soldier;

Object.setPrototypeOf(john, soldier);

// console.log(john.armor);
john.sayHello();
Ответ: Hello

Вариант с созданием:

const soldier = {
    health: 400,
    armor: 100,
    sayHello: function() {
        console.log('Hello');
    }
};

const john = Object.create(soldier);

// const john = {
//     health: 100
// };

// john.__proto__ = soldier;

Object.setPrototypeOf(john, soldier);

// console.log(john.armor);
john.sayHello();

ООП - это наука о том, как правильно делать архитектуру.

                                         Урок №24 Практика , ч4. Используем объекты

                                         'use strict';

// Задача №1

const personalMovieDB = {
    count: 0,
    movies: {},
    actors: {},
    genres: [],
    privat: false,
    start: function() {
        personalMovieDB.count  = +prompt('Сколько фильмов вы уже просмотрели?', '');
    
        while (personalMovieDB.count == '' || personalMovieDB.count == null || isNaN(personalMovieDB.count)) {
            personalMovieDB.count  = +prompt('Сколько фильмов вы уже просмотрели?', '');
        }
    },
    rememberMyFilms: function() {
        for (let i = 0; i < 2; i++) {
            const a = prompt ('Один из последних просмотренных фильмов?', ''),
                  b = prompt ('На сколько оцените его?', '');
        
            if (a != null && b != null && a != '' && b != '' && a.length < 50) {
                personalMovieDB.movies[a] = b;
                console.log('done');
            } else {
                console.log ('error');
                i--;
            }   
        
                  
        }
    },
    detectPersonalLevel: function() {
        if (personalMovieDB.count < 10) {
            console.log('Просмотрено довольно мало фильмов');
        } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
            console.log ('Вы классический зритель');
        } else if (personalMovieDB.count >= 30) {
            console.log ('Вы киноман');
        } else {
            console.log ('Произошла ошибка');
        }
    },
    showMyDB: function(hidden) {
        if (!hidden) {
            console.log(personalMovieDB); 
        }
    },

    // Задача №2

    toggleVisibleMyDB: function() {
        if (personalMovieDB.privat) {
            personalMovieDB.privat = false;
        } else {
            personalMovieDB.privat = true;
        }
    },

// Задача №3

    writeYourGenres: function() {
        for (let i = 1; i <= 3; i++) {
            let genre = prompt (`Ваш любимый жанр под номером ${i}`);

            if (genre === '' || genre === null) {
                console.log('Вы ввели некорректные данные или не ввели их вовсе');
                i--;
            } else {
                personalMovieDB.genres[i - 1] = genre;
            }
        }

        personalMovieDB.genres.forEach((item, i) => {
            console.log(`Любимый жанр ${i + 1} - это ${item}`);
        });
    }
    
};

                                            Урок №25 Отлавливаем ошибки в своем коде при помощи консоли
разработчика. Breakpoints
'use strict';

function hello () {
    console.log('Hello World');
    debugger;
}

hello();

function hi() {
    console.log('Say hi!');
}

hi();

const arr = [1, 14, 4, 30, 54],
    sorted = arr.sort(compareNum);

function compareNum(a, b) {
    return a - b;
}

console.log(sorted);

                                            Урок №26 Динамическая типизация в JS
Динамическая типизация - это возможность переделывать один тип данных в другой.

1-й способ:
console.log(typeof(String(null))); - ответ String 
console.log(String(null)); = ответ null 
console.log(typeof(String(4))); - ответ string 

1.2-й способ (Конкотинация). Т.е. сложение строки с чем-то
console.log(typeof(5 + '')); - ответ string 

const num = 5;

console.log('https://vk.com/catalog/' + num);
Ответ: https://vk.com/catalog/5

2-й способ. Как превратить что угодно в число.
console.log(typeof(Number('4'))); - ответ number

2.2-й способ. Унарный плюс.
console.log(typeof(+ '5')); - ответ number

2.3-й способ.
console.log(typeof(parseInt('15px', 10))); - ответ number

Нужно запомнить. Всё что мы получаем от пользователя всегда будет типом данных строка.

3.1-й способ. В булиновое значение.
// 0, '', null, undefined, NaN; - всегда false.

let switcher = null;

if (switcher) {
    console.log('Working...');
}
Ответ: ничего, т.к. switcher = null

let switcher = null;

if (switcher) {
    console.log('Working...');
}

switcher = 1;

if (switcher) {
    console.log('Working...');
}
Ответ: Working... (т.е. работает)

3.2-й способ
console.log(typeof(Boolean('4'))); - ответ boolean

3.3-й способ
console.log(typeof(!!'44444')); - ответ boolean

                                            Урок №27 Задачи с собеседований на понимание основ
1) Какое будет выведено значение: let x = 5; alert( x++ ); ?
Ответ: 5.

2) Чему равно такое выражение: [ ] + false - null + true ?
Ответ: NaN

3) Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?
Ответ: 2

4) Чему равна сумма [ ] + 1 + 2?
Ответ: 12

5) Что выведет этот код: alert( &quot;1&quot;[0] )?
Ответ: 1

6) Чему равно 2 && 1 && null && 0 && undefined ?
И всегда останавливается на лжи.
Или всегда запинается на правде.

Ответ: Null

7) Есть ли разница между выражениями? !!( 1 && 2 ) === (1 && 2)?
Два знака не (!!) превращает выражение в булиновое. Поэтому нет.
Ответ: false

8) Что выведет этот код: alert( null || 2 && 3 || 4 ); ?
Оператор И имеет приоритет выше. Нужно смотреть таблицу операторов по проиоритету.
Ответ: 3

9) a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?
Ответ: false
Т.к. это похожие массивы, но не идентичные. Что-то типа ящика с яблоками.

10) Что выведет этот код: alert( +'Infinity'); ?
Ответ: Infinity

11) Верно ли сравнение: 'Ёжик' > 'яблоко'?
Ответ: fasle
Нужно смотреть юникод.

12) Чему равно 0 || '' || 2 || undefined || true || falsе ?
Ответ: 2
Т.к. ИЛИ запинается на правде, а тут это 2.

                                            Урок №28 Получение элементов со страницы

1-й метод - get element by id (через тег или класс)

const box = document.getElementById('box');

console.log(box);

1.2-й метод 

const btns = document.getElementsByTagName('button')[1];

console.log(btns);
Ответ: выведет только одну button №2.

1.3-й метод 
const btns = document.getElementsByTagName('button');

console.log(btns[1]);
Ответ: button №2

1.4-й метод
const circles = document.getElementsByClassName('circle');
console.log(circles);

2-й метод. Более современный. Всегда есть метод forEach. Но это всё равно псевдомассив.
const hearts = document.querySelectorAll('.heart');

console.log(hearts);

hearts.forEach(item => {
    console.log(item);
})

2.1-й метод (querySelector). Позволяет получить только один элемент со страницы (по очереди, т.е будет брать первый).
const oneHeart = document.querySelector('.heart');
console.log(oneHeart);

Итоги: У нас есть методы, которые работают на объектной модели документов (documents) и работает только внутри браузера.
У него есть 2 метода для того чтобы получить только один элемент (getElementById (по id) и querySelector(по очереди, т.е. первый попавшийся)).
Так же мы можем получать html коллекции (псевдомассивы).
Для этого у нас есть такие методы как (getElementsByTagName, getElementsByClassName, querySelectorAll).
Здесь уже необходимо использовать какие-то индексы.
Что мы передаем в круглые скобки ?
Если ищем класс - точку ставить не надо.
Если работаем с css селектором - точка нужна.

                                            Урок №29 Действия с элементами на странице
// wrapper.append(div); вставляет в конец родителя
// wrapper.appendChild(div); устаревший

// wrapper.prepend(div); вставляет вначало родителя

// hearts[0].before(div); вставить до
// wrapper.insertBefore(div, hearts[0]); устаревший
// hearts[0].after(div); вставить после

// circles[0].remove(); удалить
// wrapper.removeChild(hearts[1]); устаревший

//hearts[0].replaceWith(circles[0]); заменить
// wrapper.replaceChild(circles[0], hearts[0]); устаревший

div.innerHTML = 'Hello world'; вставить текст в объект на странице (работает с html)
div.textContent = 'Hello'; работает только с текстом

div.insertAdjacentHTML('beforebegin', '<h2>Hello</h2>'); вставляет код перед элементом

div.insertAdjacentHTML('afterbegin', '<h2>Hello</h2>'); вставляет в начало нашего элемента 

div.insertAdjacentHTML('beforeend', '<h2>Hello</h2>'); вставялет в конец элемента 

div.insertAdjacentHTML('afterend', '<h2>Hello</h2>'); вставляет после элемента

                                            Урок №30 Практика. Задание на отработку действий со страницей
Задания на урок:

1) Удалить все рекламные блоки со страницы (правая часть сайта)

const adv = document.querySelectorAll('.promo__adv img');

adv.forEach(item => {
    item.remove();
})

2) Изменить жанр фильма, поменять "комедия" на "драма"

const adv = document.querySelectorAll('.promo__adv img'),
      poster = document.querySelector('.promo__bg'),
      genre = poster.querySelector('.promo__genre');

adv.forEach(item => {
    item.remove();
})

genre.textContent = 'драма';

3) Изменить задний фон постера с фильмом на изображение "bg.jpg". Оно лежит в папке img.
Реализовать только при помощи JS

poster.style.backgroundImage = 'url("img/bg.jpg")';

4) Список фильмов на странице сформировать на основании данных из этого JS файла.
Отсортировать их по алфавиту 

movieList.innerHTML = '';

movieDB.movies.sort();

console.log(poster.innerHTML);

movieDB.movies.forEach((film, i) => {
    movieList.innerHTML += `
        <li class="promo__interactive-item">${i + 1} ${film}
            <div class="delete"></div>
        </li>
    `;
});

5) Добавить нумерацию выведенных фильмов */

movieList.innerHTML = '';

movieDB.movies.sort();

console.log(poster.innerHTML);

movieDB.movies.forEach((film, i) => {
    movieList.innerHTML += `
        <li class="promo__interactive-item">${i + 1} ${film}
            <div class="delete"></div>
        </li>
    `;
});

                                            Урок №31 События и их обработчики
События - это сигнал от браузера о том. что что-то у нас произошло.
Обработчник - это функция которая срабатывает как только событие произошло.

Есть 3 способа назначить обработчники событий.
1) Использовать html атрибут который записывается прямо в вёрстке.
<button onclick="alert('Click')" id="btn">Нажми меня</button>
Данный способо практически не используется.

2) Использовать свойство дом дерево для событий.
const btn = document.querySelector('button');

btn.onclick = function() {
    alert('Click');
};
Такой способо так же используется редко.

3)
btn.addEventListener('click', () => {
    alert('Click');
});

btn.addEventListener('click', () => {
    alert('Second Click');
});

События в js выполняются в порядке очереди.

e - это ивент (event)

Всплытие событий - это когда обработчик событий сначала срабатывает на самом вложеном элементе, затем на родителе (если есть) и так выше и выше по иерархии.

Как назначить обработчник событий один и тот же сразу на несколько элементов ?
const btns = document.querySelectorAll('button'),
      overlay = document.querySelector('.overlay');

// btn.onclick = function() {
//     alert('Click');
// };

// btn.onclick = function() {
//     alert('Click');
// };

// let i = 0;
const deleteElement = (e) => {
    console.log(e.target);
    console.log(e.type);
    // i++;
    // if (i == 1) {
    //     btn.addEventListener('click', deleteElement);
    // }
};

// btn.addEventListener('click', deleteElement);
// overlay.addEventListener('click', deleteElement);

btns.forEach(btn => {
    btn.addEventListener('click', deleteElement);
});

const link = document.querySelector('a');

link.addEventListener('click', function(event) {
    event.preventDefault();

    console.log(event.target);
});

Опции события.
У addEventListener существует и 3-й аргумент 
btns.forEach(btn => {
    btn.addEventListener('click', deleteElement, {once: true});
});

                                            Урок №32 Навигация по DOM - элементам, data-атрибуты, преимущество for/of
console.log(document.head); - обратились к элементу body
console.log(document.documentElement); - получили просто html-ку со всем содержимым которое в нём есть
console.log(document.body.childNodes); - псевдомассив

Родительским элементом счиатется тот, который объединяет другие, находящиеся внутри него (console.log(document.body.childNodes);)

Разница между дом элементом и дом деревом.
Каждая сущность которая находится на странице она по факту будет узлом. Но не каждый узел будет элементом.

Методы при помощи которых можно путешествовать по дом дереву:
console.log(document.body.firstChild); - первый ребёнок
console.log(document.body.lastChild); - последний ребёнок 

Методы чтобы получить родителей, соседей и детей:
console.log(document.querySelector('#current').parentNode.parentNode); Ответ div.wrapper

console.log(document.querySelector('[data-current="3"]').nextSibling); - следующий сосед
console.log(document.querySelector('[data-current="3"]').previousSibling); - предыдущий сосед

Аналогичные методы предыдущим:
console.log(document.querySelector('[data-current="3"]').nextElementSibling); - получим 4-й listitem, т.е. следующйи элемент, а не ноду. Так же будет работать и с предыдущим.

console.log(document.querySelector('#current').parentElement); - получим следующий элемент 

console.log(document.body.firstElementChild); - получим первого ребенка (именно элемент)

Как перебрать всех детей внутри body и оставить только элементы (не текстовые ноды и т.д) ?
for (let node of document.body.childNodes) {
    if (node.nodeName == '#text') {
        continue;
    }

    console.log(node);
}